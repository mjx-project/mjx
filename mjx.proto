syntax = "proto3";

package mjxproto;

service Agent {
  rpc TakeAction (Observation) returns (Action) {}
}

enum PlayerIdx {
  PLAYER_IDX_0 = 0;  // 起家
  PLAYER_IDX_1 = 1;
  PLAYER_IDX_2 = 2;
  PLAYER_IDX_3 = 3;  // ラス親
}

enum Wind {
  WIND_EAST = 0;
  WIND_SOUTH = 1;
  WIND_WEST = 2;
  WIND_NORTH = 3;
}

enum RelativePlayerPos {
  RELATIVE_PLAYER_POS_SELF = 0;
  RELATIVE_PLAYER_POS_RIGHT = 1;  // 下家
  RELATIVE_PLAYER_POS_MID = 2;    // 対面
  RELATIVE_PLAYER_POS_LEFT = 3;   // 上家
}

enum ActionType {
  // After draw
  ACTION_TYPE_DISCARD_FROM_HAND = 0;
  ACTION_TYPE_DISCARD_DRAWN_TILE = 1;
  ACTION_TYPE_RIICHI = 2;
  ACTION_TYPE_CLOSED_KAN = 3;
  ACTION_TYPE_ADDED_KAN = 4;
  ACTION_TYPE_TSUMO = 5;
  ACTION_TYPE_ABORTIVE_DRAW_NINE_TERMINAL = 6;
  // After other's discard
  ACTION_TYPE_CHI = 7;
  ACTION_TYPE_PON = 8;
  ACTION_TYPE_OPEN_KAN = 9;
  ACTION_TYPE_RON = 10;
  ACTION_TYPE_NO = 11;
}

enum EventType {
  // Publicly observable action after someone's draw
  EVENT_TYPE_DISCARD_FROM_HAND = 0;
  EVENT_TYPE_DISCARD_DRAWN_TILE = 1;  // ツモ切り, Tsumogiri
  EVENT_TYPE_RIICHI = 2;
  EVENT_TYPE_CLOSED_KAN = 3;
  EVENT_TYPE_ADDED_KAN = 4;
  EVENT_TYPE_TSUMO = 5;
  EVENT_TYPE_ABORTIVE_DRAW_NINE_TERMINAL = 6;
  // Publicly observable Action after someone's discard
  EVENT_TYPE_CHI = 7;
  EVENT_TYPE_PON = 8;
  EVENT_TYPE_OPEN_KAN = 9;
  EVENT_TYPE_RON = 10;
  // State change made by environment. There is no decision making by players.  
  // 11 is skipped for the consistency to ActionType 
  EVENT_TYPE_DRAW = 12; 
  EVENT_TYPE_NEW_DORA = 13; 
  EVENT_TYPE_RIICHI_SCORE_CHANGE = 14; 
  EVENT_TYPE_ABORTIVE_DRAW_NORMAL = 15;  // 通常流局 
  EVENT_TYPE_ABORTIVE_DRAW_FOUR_RIICHIS = 16;  // 四家立直 
  EVENT_TYPE_ABORTIVE_DRAW_THREE_RONS = 17;  // 三家和了 
  EVENT_TYPE_ABORTIVE_DRAW_FOUR_KANS = 18;  // 四槓散了 
  EVENT_TYPE_ABORTIVE_DRAW_FOUR_WINDS = 19;  // 四風連打 
  EVENT_TYPE_ABORTIVE_DRAW_NAGASHI_MANGAN = 20;  // 流し満貫 
  // Round end indicator
  EVENT_TYPE_ROUND_END = 21; // Necessary to handle double ron
}

message Score {
  // Following rule holds for any timesteps: sum(score.ten) + score.riichi * 1000 == 100000
  int32 round = 1;
  int32 honba = 2;
  int32 riichi = 3;
  repeated int32 ten = 4;  
}

message Action {
  //                discard   open
  //  DISCARD           Yes     No
  //  RIICHI             No     No
  //  TSUMO              No     No
  //  CLOSED_KAN         No    Yes
  //  ADDED_KAN          No    Yes
  //  KYUSYU             No     No
  //  NO                 No     No
  //  CHI                No    Yes
  //  PON                No    Yes
  //  OPEN_KAN           No    Yes
  //  RON                No     No
  int32 game_id = 1;
  PlayerIdx who = 2;
  ActionType type = 3;
  int32 discard = 4;
  int32 open = 5;
}

message Event {
  // History of publicly observable events, which include 
  // 
  //   1. publicly observable actions taken by all layers 
  //   2. publicly observable state changes made by envionment
  // 
  // Note that "NO" action is **NOT** collected as event since it's not publicly observable.
  // Also, drawn tile is not observable. Only the fact that the player drew something is collected.
  //
  // [Table] Is who/tile/open entry set?
  //
  //                       who    tile    open
  // DRAW                  Yes    No*     No      
  // DISCARD_FROM_HAND     Yes    Yes     No
  // DISCARD_DRAWN_TILE    Yes    Yes     No
  // RIICHI                Yes    No      No
  // TSUMO                 Yes    Yes     No
  // RON                   Yes    Yes     No
  // CHI                   Yes    No      Yes
  // PON                   Yes    No      Yes
  // CLOSED_KAN            Yes    No      Yes
  // OPEN_KAN              Yes    No      Yes
  // ADDED_KAN             Yes    No      Yes
  // NEW_DORA              No     Yes     No
  // RIICHI_SCORE_CHANGE   Yes    No      No
  // ABORTIVE_DRAW         No     No      No
  //
  // *Drawn tile is not set since it's private info. 
  EventType type = 1;
  PlayerIdx who = 2;
  int32 tile = 3;
  int32 open = 4;
}

message Hand {
  PlayerIdx who = 1;
  repeated int32 closed_tiles = 2;
  repeated int32 opens = 4;
}

message PublicObservationUtil {
  Score curr_score = 1;
  repeated int32 curr_doras = 2;
  repeated int32 river = 3;
}

message PublicObservation {
  Score init_score = 1;
  int32 init_dora = 2;
  repeated Event event_history = 3;
  PublicObservationUtils utils = 10;
}

message PrivateObaservationUtils {
  Hand curr_hand = 1;
}

message PrivateObservation {
  PlayerIdx who = 1;
  repeated int32 init_hand = 2;
  repeated int32 draw_history = 3;
  PrivateObseravtionUtils utils = 4;
}

message HiddenStateUtils {
  repeated int32 curr_ura_doras = 6;
}

message HiddenState {
  repeated int32 wall = 1;
  HiddenStateUtils utils = 2;
}

message WinUtils {
  int32 fu = 6;
  repeated int32 fans = 10;  // TODO: check definitions
  repeated int32 yakus = 9;  // TODO: check definitions
  repeated int32 yakumans = 11;
  int32 ten = 7;  // TODO: check definitions
  repeated int32 ten_changes = 8;  // Required only for Tenhou mjlog.  TODO: check definition. remove
}

message Win {
  PlayerIdx who = 1;
  PlayerIdx from_who = 2;
  Hand hand = 3;
  int32 win_tile = 5;
  WinUtils utils = 12;
}

message AbortiveDrawUtils {
  EventType type = 1;
  repeated int32 ten_changes = 8;  // Required only for Tenhou mjlog.  TODO: check definition. remove
}

message AbortiveDraw {
  repeated Hand tenpai_hands = 1;
  repeated AbortiveDrawUtils = 2;
}

message RoundTerminalUtils {
  Score final_score = 1;
  bool is_game_over = 4;
}

message RoundTerminal {
  repeated Win wins = 1;   // Empty if no one wins
  AbortiveDraw abortive_draw = 2;  // Empty if a winner exists
  RoundTerminalUtils utils = 3;
}

message StateUtils {
  uint64 game_id = 1;
  uint64 game_seed = 2;
  repeated string player_ids = 3;
  RoundTerminal round_terminal = 9;
}

message State {
  HiddenState hidden_state = 1;  // Information no one can access
  PublicObservation public_observation = 2;  // Information any plaer can observe
  repeated PrivateObservation private_observation = 3;  // Information only the corresponding player can access
  StateUtils utils = 4;
}

message ObservationUtils {
  uint64 game_id = 1;
  repeated string player_ids = 2;
  repeated Action legal_actions = 3;
}

message Observation {
  PlayerIdx who = 1;
  PublicObservation public_observation = 2;
  PrivateObservation private_observation = 3;
  ObservationUtils utils = 4;
}
