# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: mjx/internal/mjx.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import List, Optional

import betterproto
import grpclib


class ActionType(betterproto.Enum):
    # After draw
    ACTION_TYPE_DISCARD = 0
    ACTION_TYPE_TSUMOGIRI = 1
    ACTION_TYPE_RIICHI = 2
    ACTION_TYPE_CLOSED_KAN = 3
    ACTION_TYPE_ADDED_KAN = 4
    ACTION_TYPE_TSUMO = 5
    ACTION_TYPE_ABORTIVE_DRAW_NINE_TERMINALS = 6
    # After other's discard
    ACTION_TYPE_CHI = 7
    ACTION_TYPE_PON = 8
    ACTION_TYPE_OPEN_KAN = 9
    ACTION_TYPE_RON = 10
    ACTION_TYPE_NO = 11
    # Dummy used only to check connection and share round terminal information
    ACTION_TYPE_DUMMY = 99


class EventType(betterproto.Enum):
    # Publicly observable actions
    EVENT_TYPE_DISCARD = 0
    EVENT_TYPE_TSUMOGIRI = 1
    EVENT_TYPE_RIICHI = 2
    EVENT_TYPE_CLOSED_KAN = 3
    EVENT_TYPE_ADDED_KAN = 4
    EVENT_TYPE_TSUMO = 5
    EVENT_TYPE_ABORTIVE_DRAW_NINE_TERMINALS = 6
    EVENT_TYPE_CHI = 7
    EVENT_TYPE_PON = 8
    EVENT_TYPE_OPEN_KAN = 9
    EVENT_TYPE_RON = 10
    # State transitions made by environment. There is no decision making by
    # players. 11 is skipped for the consistency to ActionType
    EVENT_TYPE_DRAW = 12
    EVENT_TYPE_RIICHI_SCORE_CHANGE = 13
    EVENT_TYPE_NEW_DORA = 14
    EVENT_TYPE_ABORTIVE_DRAW_FOUR_RIICHIS = 15
    EVENT_TYPE_ABORTIVE_DRAW_THREE_RONS = 16
    EVENT_TYPE_ABORTIVE_DRAW_FOUR_KANS = 17
    EVENT_TYPE_ABORTIVE_DRAW_FOUR_WINDS = 18
    EVENT_TYPE_EXHAUSTIVE_DRAW_NORMAL = 19
    EVENT_TYPE_EXHAUSTIVE_DRAW_NAGASHI_MANGAN = 20


@dataclass
class Score(betterproto.Message):
    round: int = betterproto.uint32_field(1)
    honba: int = betterproto.uint32_field(2)
    riichi: int = betterproto.uint32_field(3)
    tens: List[int] = betterproto.int32_field(4)


@dataclass
class Event(betterproto.Message):
    # Publicly observable event, which include   1. publicly observable and
    # actually realized actions taken by all layers   2. publicly observable
    # state transitions made by envionment Note that "No" action is **NOT**
    # collected as event since it's not publicly observable. Also, "Chi"
    # prevented by other player's "Pon/Ron" is also **NOT** collected in
    # event_history. Drawn tile does not use tile entry because it's not publicly
    # observable. Only the fact that the player drew something is collected.
    # Table. Is who/tile/open entry set?                                    who
    # tile    open  0. DISCARD                        Yes     Yes      No  1.
    # TSUMOGIRI                      Yes     Yes      No  2. RIICHI
    # Yes      No      No  3. CLOSED_KAN                     Yes      No     Yes
    # 4. ADDED_KAN                      Yes      No     Yes  5. TSUMO
    # Yes     Yes      No  6. ABORTIVE_DRAW_NINE_TERMINALS   Yes      No      No
    # 7. CHI                            Yes      No     Yes  8. PON
    # Yes      No     Yes  9. OPEN_KAN                       Yes      No     Yes
    # 10. RON                            Yes     Yes      No 12. DRAW
    # Yes      No      No 13. RIICHI_SCORE_CHANGE            Yes      No      No
    # 14. NEW_DORA                        No     Yes      No 15.
    # ABORTIVE_DRAW_FOUR_RIICHIS      No      No      No 16.
    # ABORTIVE_DRAW_THREE_RONS        No      No      No 17.
    # ABORTIVE_DRAW_FOUR_KANS         No      No      No 18.
    # ABORTIVE_DRAW_FOUR_WINDS        No      No      No 19.
    # EXHAUSTIVE_DRAW_NORMAL          No      No      No 20.
    # EXHAUSTIVE_DRAW_NAGASHI_MANGAN  No      No      No
    type: "EventType" = betterproto.enum_field(1)
    who: int = betterproto.int32_field(2)
    tile: int = betterproto.uint32_field(3)
    open: int = betterproto.uint32_field(4)


@dataclass
class PublicObservation(betterproto.Message):
    game_id: str = betterproto.string_field(1)
    player_ids: List[str] = betterproto.string_field(2)
    init_score: "Score" = betterproto.message_field(3)
    dora_indicators: List[int] = betterproto.uint32_field(4)
    events: List["Event"] = betterproto.message_field(5)


@dataclass
class Hand(betterproto.Message):
    closed_tiles: List[int] = betterproto.uint32_field(1)
    opens: List[int] = betterproto.uint32_field(2)


@dataclass
class PrivateObservation(betterproto.Message):
    who: int = betterproto.int32_field(1)
    init_hand: "Hand" = betterproto.message_field(2)
    draw_history: List[int] = betterproto.uint32_field(3)
    curr_hand: "Hand" = betterproto.message_field(4)


@dataclass
class Observation(betterproto.Message):
    who: int = betterproto.int32_field(1)
    public_observation: "PublicObservation" = betterproto.message_field(2)
    private_observation: "PrivateObservation" = betterproto.message_field(3)
    round_terminal: "RoundTerminal" = betterproto.message_field(4)
    possible_actions: List["Action"] = betterproto.message_field(5)


@dataclass
class Win(betterproto.Message):
    who: int = betterproto.int32_field(1)
    from_who: int = betterproto.int32_field(2)
    hand: "Hand" = betterproto.message_field(3)
    win_tile: int = betterproto.uint32_field(4)
    fu: int = betterproto.uint32_field(5)
    ten: int = betterproto.uint32_field(6)
    ten_changes: List[int] = betterproto.int32_field(7)
    yakus: List[int] = betterproto.uint32_field(8)
    fans: List[int] = betterproto.uint32_field(9)
    yakumans: List[int] = betterproto.uint32_field(10)
    ura_dora_indicators: List[int] = betterproto.uint32_field(11)


@dataclass
class NoWinner(betterproto.Message):
    tenpais: List["TenpaiHand"] = betterproto.message_field(1)
    ten_changes: List[int] = betterproto.int32_field(2)


@dataclass
class TenpaiHand(betterproto.Message):
    who: int = betterproto.int32_field(1)
    hand: "Hand" = betterproto.message_field(2)


@dataclass
class RoundTerminal(betterproto.Message):
    final_score: "Score" = betterproto.message_field(1)
    wins: List["Win"] = betterproto.message_field(2)
    no_winner: "NoWinner" = betterproto.message_field(3)
    is_game_over: bool = betterproto.bool_field(4)


@dataclass
class State(betterproto.Message):
    hidden_state: "HiddenState" = betterproto.message_field(1)
    public_observation: "PublicObservation" = betterproto.message_field(2)
    private_observations: List["PrivateObservation"] = betterproto.message_field(3)
    round_terminal: "RoundTerminal" = betterproto.message_field(4)


@dataclass
class HiddenState(betterproto.Message):
    game_seed: int = betterproto.uint64_field(1)
    wall: List[int] = betterproto.uint32_field(2)
    ura_dora_indicators: List[int] = betterproto.uint32_field(3)


@dataclass
class Action(betterproto.Message):
    # discard   open  DISCARD           Yes     No  RIICHI             No     No
    # TSUMO              No     No  CLOSED_KAN         No    Yes  ADDED_KAN
    # No    Yes  KYUSYU             No     No  NO                 No     No  CHI
    # No    Yes  PON                No    Yes  OPEN_KAN           No    Yes  RON
    # No     No
    game_id: str = betterproto.string_field(1)
    who: int = betterproto.int32_field(2)
    type: "ActionType" = betterproto.enum_field(3)
    discard: int = betterproto.uint32_field(4)
    open: int = betterproto.uint32_field(5)


class AgentStub(betterproto.ServiceStub):
    async def take_action(
        self,
        *,
        who: int = 0,
        public_observation: Optional["PublicObservation"] = None,
        private_observation: Optional["PrivateObservation"] = None,
        round_terminal: Optional["RoundTerminal"] = None,
        possible_actions: List["Action"] = [],
    ) -> Action:
        request = Observation()
        request.who = who
        if public_observation is not None:
            request.public_observation = public_observation
        if private_observation is not None:
            request.private_observation = private_observation
        if round_terminal is not None:
            request.round_terminal = round_terminal
        if possible_actions is not None:
            request.possible_actions = possible_actions

        return await self._unary_unary(
            "/mjxproto.Agent/TakeAction",
            request,
            Action,
        )
