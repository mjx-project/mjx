@startuml

top to bottom direction

set namespaceSeparator ::

class mj::Environment {
    - agents: Agent
    - state: State
    + Run(): void
    + RunOneGame(): void
    + RunOneRound(): void
}

class mj::YakuEvaluator <<(S,orange) Static>> {
    + {static} Has(): bool
    + {static} Eval(): mj::WinScore
}

class mj::WinHandCache <<(S,orchid) Singleton>> {
    - win_cache
    - tenpai_cache
    + Has(): bool
}

class mj::WinStateInfo <<(D,yellow) Data>> {
    + seat_wind
    + prevalent_wind
    + is_bottom
    + is_ippatsu
    + is_double_riichi
    + is_first_tsumo
    + is_dealer
    + dora
    + reversed_dora
}

class mj::WinInfo <<(D,yellow) Data>> {
    + win_state_info
    + win_hand_info
    + Ron(): WinInfo&
}

class mj::WinScore <<(D,yellow) Data>> {
    + yakuman: map<mj::Yaku, int>
    + yaku: map<mj::Yaku, bool>
    + fu: optional<int>
}

class mj::WinHandInfo <<(D,yellow) Data>> {
    + opens: vector<Open>
    + closed_tiles: unordered_set<mj::Tile, HashTile> 
    + last_tile_added: std::optional<Tile> 
    + stage: HandStage 
    + under_riichi bool 
    + closed_tile_types: TileTypeCount 
    + all_tile_types: TileTypeCount 
    + is_menzen: bool
}

class mj::State {
    - score: Score
    - stage: RoundStage
    - dealer: AbsolutePos
    - drawer: AbsolutePos
    - wall: Wall
    - players: array<Player, 4>
    - event_history: mjproto::EventHistory
    - private_infos: vector<mjproto::InitHand>
    + InitRound(): void
    + CreateObservation(): pair<AbsolutePos, Observation>
    + UpdateState(Action): void
    + IsRoundOver(): bool
    - PossibleActions(): vector<Action>
    - UpdateStateByDraw(): mj::Tile
    - UpdateStateByAction(): void
    - UpdateStateByActionCandidates(): void
}

class mj::Observation <<(D,yellow) Data>> {
    - observation mjproto::Observation
}

abstract class mj::Agent {
    + TakeAction(): Action
}

class mj::AgentExampleRuleBased {
    + TakeAction(): Action
}

class mj::AgentGrpcClient {
    + TakeAction(): Action
}

class mj::AgentGrpcServer {
    + RunServer(): void
}

class mj::AgentGrpcServerImplExample{

}

class mj::Wall {
    - tiles: vector<Tile>
    + <<get>> initial_hands(): array<Hand, 4>
    + <<get>> doras(): vector<Tile>
    + <<get>> ura_doras(): vector<Tile>
    + Draw(): Tile
    + KanDraw(): Tile
    + AddKanDora()
    + HasDrawLeft(): bool
}

class mj::Action <<(D,yellow) Data>> {
    - action_response mjproto::Action
}

class mj::Hand {
    - stage
    - last_tile_added
    - closed_tiles
    - opens
    - undiscardable_tiles
    - under_riichi
    + PossibleDiscards()
    + PossibleDiscardsAfterRiichi()
    + PossibleOpensAfterOthersDiscard()
    + PossibleOpensAfterDraw()
    + CanRon()
    + IsCompleted()
    + CanRiichi()
    + Draw()
    + Riichi()
    + ApplyOpen()
    + Ron()
    + RonAfterOthersKan()
    + Tsumo()
    + Discard()

}

class mj::Open {
    - bits: int
    + <<get>> type()
    + <<get>> from()
    + <<get>> at()
    + <<get>> size()
    + <<get>> tiles()
    + <<get>> tiles_from_hand()
    + <<get>> stolen_tile()
    + <<get>> last_tile()
    + <<get>> undiscardable_tile_types()
    + <<get>> bits()
}

class mj::Chi <<(S,orange) Static>> {
    + Create(): Open
}

class mj::Pon <<(S,orange) Static>> {
    + Create(): Open
}

class mj::KanOpened <<(S,orange) Static>> {
    + Create(): Open
}

class mj::KanClosed <<(S,orange) Static>> {
    + Create(): Open
}

class mj::KanAdded <<(S,orange) Static>> {
    + Create(): Open
}

class mj::Tile {
    + id
    + type
}


mj::Environment "1" *-- "4" mj::Agent
mj::Environment *-- mj::State 

mj::State <-- mj::Action : UpdateStateByAction
mj::State *-- mj::Wall
mj::State "1" *-- "4" mj::Hand
mj::State --> mj::Observation : CreateObservation
mj::State --> mj::WinStateInfo

mj::Observation --> mj::Agent : TakeAction

mj::Hand "0" *-- "1..4" mj::Open
mj::Hand -- mj::WinHandCache 
mj::Hand --> mj::WinHandInfo

mj::Open <-- mj::Chi : Create
mj::Open <-- mj::Pon : Create
mj::Open <-- mj::KanClosed : Create
mj::Open <-- mj::KanOpened : Create
mj::Open <-- mj::KanAdded : Create

mj::WinHandInfo --> mj::WinInfo
mj::WinStateInfo --> mj::WinInfo
mj::WinInfo --> mj::YakuEvaluator : Has, Eval
mj::WinScore --> mj::State

mj::YakuEvaluator -- mj::WinHandCache
mj::YakuEvaluator --> mj::WinScore : Eval

mj::Agent --> mj::Action : TakeAction
mj::Agent <|-- mj::AgentExampleRuleBased
mj::Agent <|-- mj::AgentGrpcClient
mj::AgentGrpcClient --> mj::AgentGrpcServer : <<mjproto::Observation>>

mj::AgentGrpcServer --> mj::AgentGrpcClient : <<mjproto::Action>>
mj::AgentGrpcServer *-- mj::AgentGrpcServerImplExample


@enduml